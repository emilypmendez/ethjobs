{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-319e47694a9b685ff886d03964f0d41e9587384c",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/EthJobsEscrow.sol": "project/contracts/EthJobsEscrow.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/EthJobsEscrow.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.28;\n\n// ERC20 interface for PYUSD\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract EthJobsEscrow {\n  event JobCreated(uint256 indexed jobId, address indexed employer, address indexed employee, uint256 amount, uint256 deadline);\n  event FundsReleased(uint256 indexed jobId, address indexed employee, uint256 amount);\n  event FundsRefunded(uint256 indexed jobId, address indexed employer, uint256 amount);\n  event EscrowFunded(uint256 indexed jobId, address indexed employer, uint256 amount);\n  \n  // PYUSD token address\n  address public constant PYUSD_TOKEN = 0xCaC524BcA292aaade2DF8A05cC58F0a65B1B3bB9;\n  \n  // Job structure\n  struct Job {\n    address employer;\n    address employee;\n    uint256 amount;\n    uint256 deadline;\n    bool isFunded;\n    bool isCompleted;\n    bool isRefunded;\n  }\n  \n  // State variables\n  uint256 public nextJobId;\n  mapping(uint256 => Job) public jobs;\n  \n  constructor() {\n    nextJobId = 1;\n  }\n  \n  modifier onlyEmployer(uint256 _jobId) {\n    require(jobs[_jobId].employer == msg.sender, \"Only employer can call this function\");\n    _;\n  }\n  \n  modifier jobExists(uint256 _jobId) {\n    require(_jobId > 0 && _jobId < nextJobId, \"Job does not exist\");\n    _;\n  }\n  \n  modifier onlyWhenFunded(uint256 _jobId) {\n    require(jobs[_jobId].isFunded, \"Job must be funded first\");\n    _;\n  }\n  \n  /**\n   * @notice Create a new job escrow\n   * @param _employee The employee's address\n   * @param _deadline The deadline timestamp\n   * @param _amount The amount of PYUSD to deposit\n   * @return jobId The ID of the created job\n   */\n  function createJob(\n    address _employee,\n    uint256 _deadline,\n    uint256 _amount\n  ) external returns (uint256 jobId) {\n    require(_employee != address(0), \"Invalid employee address\");\n    require(_amount > 0, \"Amount must be greater than 0\");\n    require(_deadline > block.timestamp, \"Deadline must be in the future\");\n    \n    jobId = nextJobId;\n    nextJobId++;\n    \n    jobs[jobId] = Job({\n      employer: msg.sender,\n      employee: _employee,\n      amount: _amount,\n      deadline: _deadline,\n      isFunded: false,\n      isCompleted: false,\n      isRefunded: false\n    });\n    \n    emit JobCreated(jobId, msg.sender, _employee, _amount, _deadline);\n  }\n  \n  /**\n   * @notice Fund a job escrow with PYUSD after approval\n   * @param _jobId The ID of the job to fund\n   */\n  function fundJob(uint256 _jobId) external jobExists(_jobId) onlyEmployer(_jobId) {\n    Job storage job = jobs[_jobId];\n    require(!job.isFunded, \"Job is already funded\");\n    require(!job.isCompleted, \"Job is already completed\");\n    require(!job.isRefunded, \"Job is already refunded\");\n    \n    // Check if employer has approved enough PYUSD\n    IERC20 pyusd = IERC20(PYUSD_TOKEN);\n    require(\n      pyusd.allowance(msg.sender, address(this)) >= job.amount,\n      \"Insufficient PYUSD allowance\"\n    );\n    \n    // Transfer PYUSD from employer to contract\n    bool transferSuccess = pyusd.transferFrom(msg.sender, address(this), job.amount);\n    require(transferSuccess, \"PYUSD transfer failed\");\n    \n    job.isFunded = true;\n    emit EscrowFunded(_jobId, msg.sender, job.amount);\n  }\n  \n  /**\n   * @notice Release funds to employee when job is completed\n   * @param _jobId The ID of the job to release funds for\n   */\n  function releaseFunds(uint256 _jobId) external jobExists(_jobId) onlyEmployer(_jobId) onlyWhenFunded(_jobId) {\n    Job storage job = jobs[_jobId];\n    require(!job.isCompleted, \"Job is already completed\");\n    require(!job.isRefunded, \"Job is already refunded\");\n    require(job.amount > 0, \"No funds to release\");\n    \n    uint256 amountToSend = job.amount;\n    job.amount = 0;\n    job.isCompleted = true;\n    \n    // Transfer PYUSD to employee\n    bool success = IERC20(PYUSD_TOKEN).transfer(job.employee, amountToSend);\n    require(success, \"PYUSD transfer failed\");\n    \n    emit FundsReleased(_jobId, job.employee, amountToSend);\n  }\n  \n  /**\n   * @notice Refund funds to employer if deadline has passed\n   * @param _jobId The ID of the job to refund\n   */\n  function refund(uint256 _jobId) external jobExists(_jobId) onlyEmployer(_jobId) onlyWhenFunded(_jobId) {\n    Job storage job = jobs[_jobId];\n    require(block.timestamp > job.deadline, \"Deadline has not passed yet\");\n    require(!job.isCompleted, \"Job is already completed\");\n    require(!job.isRefunded, \"Job is already refunded\");\n    require(job.amount > 0, \"No funds to refund\");\n    \n    uint256 amountToRefund = job.amount;\n    job.amount = 0;\n    job.isRefunded = true;\n    \n    // Transfer PYUSD back to employer\n    bool success = IERC20(PYUSD_TOKEN).transfer(job.employer, amountToRefund);\n    require(success, \"PYUSD transfer failed\");\n    \n    emit FundsRefunded(_jobId, job.employer, amountToRefund);\n  }\n  \n  /**\n   * @notice Get job details\n   * @param _jobId The ID of the job\n   * @return _employer The employer's address\n   * @return _employee The employee's address\n   * @return _amount The amount deposited for the job\n   * @return _deadline The deadline timestamp\n   * @return _isFunded Whether the job has been funded\n   * @return _isCompleted Whether the job has been completed\n   * @return _isRefunded Whether the job has been refunded\n   */\n  function getJob(uint256 _jobId) external view jobExists(_jobId) returns (\n    address _employer,\n    address _employee,\n    uint256 _amount,\n    uint256 _deadline,\n    bool _isFunded,\n    bool _isCompleted,\n    bool _isRefunded\n  ) {\n    Job storage job = jobs[_jobId];\n    return (\n      job.employer,\n      job.employee,\n      job.amount,\n      job.deadline,\n      job.isFunded,\n      job.isCompleted,\n      job.isRefunded\n    );\n  }\n  \n  /**\n   * @notice Get all job IDs for an employer\n   * @param _employer The employer's address\n   * @return Array of job IDs\n   */\n  function getEmployerJobs(address _employer) external view returns (uint256[] memory) {\n    uint256[] memory employerJobs = new uint256[](nextJobId - 1);\n    uint256 count = 0;\n    \n    for (uint256 i = 1; i < nextJobId; i++) {\n      if (jobs[i].employer == _employer) {\n        employerJobs[count] = i;\n        count++;\n      }\n    }\n    \n    // Resize array to actual count\n    assembly {\n      mstore(employerJobs, count)\n    }\n    \n    return employerJobs;\n  }\n  \n  /**\n   * @notice Get all job IDs for an employee\n   * @param _employee The employee's address\n   * @return Array of job IDs\n   */\n  function getEmployeeJobs(address _employee) external view returns (uint256[] memory) {\n    uint256[] memory employeeJobs = new uint256[](nextJobId - 1);\n    uint256 count = 0;\n    \n    for (uint256 i = 1; i < nextJobId; i++) {\n      if (jobs[i].employee == _employee) {\n        employeeJobs[count] = i;\n        count++;\n      }\n    }\n    \n    // Resize array to actual count\n    assembly {\n      mstore(employeeJobs, count)\n    }\n    \n    return employeeJobs;\n  }\n  \n  /**\n   * @notice Get total number of jobs\n   * @return Total count of jobs\n   */\n  function getTotalJobs() external view returns (uint256) {\n    return nextJobId - 1;\n  }\n  \n  /**\n   * @notice Get the PYUSD balance of the contract\n   */\n  function getPYUSDBalance() external view returns (uint256) {\n    return IERC20(PYUSD_TOKEN).balanceOf(address(this));\n  }\n  \n  /**\n   * @notice Prevents anyone from sending ETH directly to the contract\n   * @dev This contract only works with PYUSD tokens\n   */\n  receive() external payable {\n    revert(\"This contract only accepts PYUSD tokens. ETH transfers not allowed.\");\n  }\n}"
      }
    }
  }
}